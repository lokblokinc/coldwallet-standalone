<%- layout('layout-minimal') %>

<script type="text/javascript" src="https://cdn.rawgit.com/ricmoo/aes-js/e27b99df/index.js"></script>
<script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>

<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"/>

<style>
.custom-modal {
  position: fixed;
  top: 50%;
  left: 50%;
  width: 100%;
  height: 100%;
  background: transparent !important;
  background-color: rgba(0,0,0,0.5) !important;

  outline: none !important;
  border: none !important;
  box-shadow: none !important;

  z-index: 10500;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important; 
  
  opacity: 1;
  visibility: visible;
  transition: opacity 0.2s ease;
}

.custom-modal.hidden {
  display: none !important;
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
}

.custom-modal-content {
  background: #fff;
  width: 90%;
  max-width: 380px;
  border-radius: 16px;

  box-shadow: none !important;
  -webkit-box-shadow: none !important;
  
  outline: none !important;
  border: 1px solid #dee2e6;

  padding: 30px;
  text-align: center;
  position: relative;
  margin: auto;
  animation: modalPop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.close-icon {
  position: absolute;
  top: 15px;
  right: 15px;
  background: transparent;
  border: none;
  font-size: 1.5rem;
  line-height: 1;
  cursor: pointer;
  color: #999;
  transition: color 0.2s;
}
.close-icon:hover { color: #333; }

#custom-qr-canvas {
  display: block;
  max-width: 100%;
  height: auto;
  border: 1px solid #eee;
  padding: 10px;
  border-radius: 12px;
  margin: 0 auto 15px auto;
  box-shadow: none !important;
}

/* Specific style for scanner box */
#qr-reader {
    width: 100%;
    background: #f8f9fa;
    border-radius: 8px;
    overflow: hidden;
    margin-bottom: 15px;
    border: 1px solid #dee2e6;
}

@keyframes modalPop {
  0% { transform: scale(0.9); opacity: 0;
}
  100% { transform: scale(1); opacity: 1; }
}

.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
.progress-wrap{border:1px solid #dee2e6;border-radius:.5rem;padding:12px;background:#f8f9fa}
.progress-title{font-weight:600;margin-bottom:.25rem}
.badge-lg{font-size:1rem;padding:.6em .8em}
#prompt-area{min-height:64px}
#prompt-text{margin:0}
select.form-control.centered { text-align: center; text-align-last: center;
margin-bottom: 2%; }
select.form-control.centered option { text-align: center; }
</style>

<main class="container my-4">
  <header class="mb-3 d-flex justify-content-between align-items-center">
    <h1 style="margin:0">Cold Wallet</h1>
    <p style="margin:6px 0 0; opacity:.8; font-size:.95rem">Build a local 2‚Äëof‚Äë3 cold wallet and expose QR requests for balance/transactions</p>
  </header>

  <div id="panel-create" class="card shadow p-4">
    
    <div class="d-flex flex-wrap align-items-center justify-content-between w-100 mb-4">
      <h2 class="mb-0">Wallet Operations</h2>

      <div class="d-flex align-items-center gap-3">
        <div>
            
            <label for="existing-wallets" class="form-label me-2 mb-0">Select Wallet</label>
            <select id="existing-wallets" class="form-select" style="width: auto; min-width: 450px;">
                <option value="" selected>-- Create New --</option>
            </select>
        </div>

        <div>
            <label for="asset-select" class="form-label me-2 mb-0">Asset</label>
            
            <select id="asset-select" class="form-select" style="width: auto;
            min-width: 100px;">
              <option value="BTC">BTC</option>
              <option value="ETH" selected>ETH</option>
              <option value="XRP">XRP</option> 
            </select>
        </div>
      </div>
    </div>

    <div id="created-address-wrap" class="d-none w-100 mb-3">
      <div class="text-center">
        <span class="badge bg-success mb-2">Active Wallet</span>
      </div>
      
       <div class="d-flex justify-content-center align-items-center">
        <span class="me-2 fw-bold">Address:</span>
        <code id="created-address" class="mono me-2 fs-5"></code>
        <button id="btn-copy-addr" class="btn btn-sm btn-outline-secondary" title="Copy to clipboard">
            üìã
        </button>
       </div>
    </div>

    <p id="pin-instruction-text" class="text-muted">
      You'll be asked to enter a PIN for <strong>each Toughkey</strong>, one by one when asked.
    </p>

    <div class="row g-4">
      <div class="col-lg-6 d-flex flex-column justify-content-center">
        
        <button id="btn-start-create" class="btn btn-primary btn-lg w-100 mb-3">Create new wallet</button>
        
        <button id="btn-show-qr" class="btn btn-outline-dark btn-lg w-100" disabled>
          Show Address QR
        </button>

      </div>

      <div class="col-lg-6">
     
        <div id="pin-block" class="mt-2 d-none card p-3 bg-light border-warning">
          <label class="form-label">
             Enter PIN for <strong id="pin-card-label">Toughkey</strong>
          </label>
          <input type="password" id="pin-input" class="form-control" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢" inputmode="numeric" maxlength="12" autocomplete="off"/>
          <button id="btn-submit-pin" class="btn btn-success mt-2 w-100">Continue</button>
        </div>

        <div id="prompt-area" class="alert alert-secondary mt-3 mb-0 text-center">
          <p id="prompt-text" class="fw-semibold mb-0">Ready to start.</p>
        </div>
  
        <div class="progress-wrap mt-3">
          <div class="progress-title">Group progress</div>
          <div class="d-flex justify-content-center gap-3 mt-2">
            <span class="badge badge-lg text-bg-primary">
                Toughkeys Enrolled: <span id="pe">0</span> / 3
            </span>
            <span 
            class="badge badge-lg text-bg-info">
                TSS Shares Generated: <span id="pkr">0</span> / 3
            </span>
          </div>
        </div>
      </div>
    </div>

    <div class="mt-4 pt-4 border-top">
      <h4 class="mb-3">Transaction Creation</h4>
      
      <div class="row g-3 align-items-end">
        <div class="col-md-4">
          <label for="recipient-address" class="form-label">Receiver Address</label>
          <input type="text" id="recipient-address" class="form-control" placeholder="Enter destination (e.g. 0x...)" autocomplete="off">
        </div>

        <div class="col-md-2">
            <button class="btn btn-outline-secondary"
                type="button"
                id="btn-scan-recipient"
                title="Scan QR Address">
          Import Address üì∑
          </button>
        </div>

        <div class="col-md-3">
          <label for="transaction-amount" class="form-label">Amount</label>
          <input type="number" id="transaction-amount" class="form-control" placeholder="0.00" step="any" min="0" autocomplete="off">
        </div>

        <div class="col-md-3 align-self-end">
          <button id="btn-show-tx-qr" class="btn btn-dark w-100" disabled>
            Show QR
          </button>
        </div>
      </div>
    </div>

    <div class="mt-4 pt-4 border-top">
        <h4 class="mb-3">Transaction Signature</h4>
        <p class="text-muted small">Scan a transaction QR to load the hash, then sign it to generate the result.</p>

        <div class="row g-3 align-items-end">
            <div class="col-md-6">
                 <label for="tx-hash-display" class="form-label">Transaction Hash (Ready to Sign)</label>
                <input type="text" id="tx-hash-display" class="form-control mono" placeholder="Waiting for scan..." readonly style="background-color: #f8f9fa; color: #666;">
            </div>
            
            <div class="col-md-2">
                <button id="btn-scan-qr" class="btn btn-outline-primary w-100" title="Scan QR with Webcam">
                  üì∑ Scan
                </button>
             </div>

            <div class="col-md-2">
                 <label for="signer-select" class="form-label" style="font-size: 0.8rem; margin-bottom: 0.2rem;">Signer</label>
                 <select id="signer-select" class="form-select">
                    <option value="" selected disabled>Select Wallet First</option>
                    </select>
            </div>

            <div class="col-md-2">
                <button id="btn-sign-tx" class="btn btn-success w-100" disabled title="Sign and Generate QR">
                  ‚úçÔ∏è Sign (0/2)
                 </button>
            </div>
        </div>
     </div>

  </div>
</main>

<div id="customQRModal" class="custom-modal hidden">
  <div class="custom-modal-content">
    <button class="close-icon" id="btn-close-custom-qr">&times;</button>
    
    <h4 id="qr-modal-title" class="mb-4 fw-bold">Wallet QR</h4>
    
    <canvas id="custom-qr-canvas" width="250" height="250"></canvas>
    
    <p id="qr-modal-desc" class="text-muted small mt-3 mb-4">
      Scan with your mobile app
    </p>
    
    <button class="btn btn-outline-secondary w-100 py-2" id="btn-close-custom-qr-2">Close</button>
  </div>
</div>

<div id="scanQRModal" class="custom-modal hidden">
    <div class="custom-modal-content" style="max-width: 500px;">
 
      <button class="close-icon" id="btn-close-scan">&times;</button>
      
      <h4 class="mb-3 fw-bold">Scan QR</h4>
      
      <div id="qr-reader"></div>
      
      <p class="text-muted small mt-3 mb-0">
        Point your camera at the QR code
      </p>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>
<script src="/plug-ins/coldwallet/assets/js/tssparticipant.js"></script>

<script>
  // Environment vars
  window.CW_ENV = {
    WS_CARD_1: "<%= (process.env.WS_CARD_1 || 'ws://localhost:8001/ws') %>",
    WS_CARD_2: "<%= (process.env.WS_CARD_2 || 'ws://localhost:8002/ws') %>",
    WS_CARD_3: "<%= (process.env.WS_CARD_3 || 'ws://localhost:8003/ws') %>",
    WS_MANAGER: "<%= (process.env.WS_MANAGER || 'wss://tsskeymanager-sdk.azurewebsites.net/ws') %>"
  };
</script>
<script src="/js/coldwallet.js"></script>

<script type="module">

let TSSAddress;
let messageToSign, rawTransaction;
let currentSessionId = null; // API Session ID

// State for multi-signature management
let currentSignatures = new Set(); 

async function sendStatusWithTimeout(apiManager, params, timeoutMs = 90000) {
  try {
    console.log(`[Status] Requesting enrollment status with ${timeoutMs/1000}s timeout...`);
    const result = await apiManager._sendAndWait('Info_Enrollment', params, 'ENROLLMENT_STATUS', timeoutMs);
    console.log(`[Status] Received enrollment status:`, result);
    return result;
  } catch (error) 
  {
    console.error(`[Status] Error during enrollment status request:`, error);
    if (error.message.includes('timeout waiting for ENROLLMENT_STATUS')) {
      console.log(`[Status] Enrollment process taking longer than ${timeoutMs/1000} seconds`);
    }
    throw error;
  }
}

let wallet = { address: 'mw6hpfazea7tCcnDLuiH4CWZ8sf8z6nfXs', partyId: null, participants: [], token: null, balance: '0', pins: [] };
let partyId = '';
let cachedParties = []; // Global cache for loaded wallets

let pendingPinResolve, pendingPinResolveSign;
let successReceived = false;
/*************** ENCRYPTION AND PIN HELPERS ***************/
function encryptUsingAES(plainText) {
    const keyBytes = aesjs.utils.utf8.toBytes('4512631236589784');
    const ivBytes = aesjs.utils.utf8.toBytes('4512631236589784');
    const textBytes = aesjs.utils.utf8.toBytes(plainText);
    const padded = aesjs.padding.pkcs7.pad(textBytes.slice());
    const aesCbc = new aesjs.ModeOfOperation.cbc(keyBytes, ivBytes);
    const encryptedBytes = aesCbc.encrypt(padded);
    return bytesToBase64(encryptedBytes);
}

function bytesToBase64(bytes) {
    let bin = '';
    for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
    return btoa(bin);
}

/*************** UI HELPERS ***************/
const $ = (sel) => document.querySelector(sel);

const peEl  = document.getElementById('pe');
const pkrEl = document.getElementById('pkr');
let countersLocked = false;
const updatePE  = (n, { force = false } = {}) => {
  if (countersLocked && !force) return;
  peEl.textContent = String(n);
};
const updatePKR = (n, { force = false } = {}) => {
  if (countersLocked && !force) return;
  pkrEl.textContent = String(n);
};

const createdAddressWrap = document.getElementById('created-address-wrap');
const createdAddressEl   = document.getElementById('created-address');
function showCreatedAddress(addr) {
  createdAddressEl.textContent = addr || '(unknown)';
  createdAddressWrap.classList.remove('d-none');
}

// Single prompt API
const promptText = document.getElementById('prompt-text');
let promptLocked = false;

function setPrompt(text, { force = false } = {}) {
  // If we want to force update (e.g., during signing), ignore lock
  if (promptLocked && !force) return;
  if(promptText) promptText.textContent = text || '';
}

const sleep = (ms) => new Promise(r => setTimeout(r, ms));
// Create flow button states
const btnStartCreate = document.getElementById('btn-start-create');
const btnShowQr = document.getElementById('btn-show-qr');
const btnShowTxQr = document.getElementById('btn-show-tx-qr');
const btnSignTx = document.getElementById('btn-sign-tx');
const BTN_TEXT_IDLE = 'Create new wallet';
const BTN_TEXT_INPROGRESS = 'Wallet creation in progress...';
const BTN_TEXT_FINALIZING = 'Wallet Creation Complete';
const BTN_TEXT_COMPLETE = 'Wallet Created';

let successHandled = false;            
const holds = new Set();
function updateCreateButton() {
    if (holds.size > 0) {
      btnStartCreate.disabled = true;
      btnStartCreate.textContent = successReceived ? BTN_TEXT_FINALIZING : BTN_TEXT_INPROGRESS;
      return;
    }
    if (successReceived) {
      btnStartCreate.disabled = true;
      btnStartCreate.textContent = BTN_TEXT_COMPLETE;
      btnShowQr.disabled = false;
      if(btnShowTxQr) btnShowTxQr.disabled = false;
    } else {
      btnStartCreate.disabled = true;
      btnStartCreate.textContent = BTN_TEXT_INPROGRESS;
    }
}

function holdButton(reason) {
    holds.add(reason);
    updateCreateButton();
}

function releaseButton(reason) {
    holds.delete(reason);
    updateCreateButton();
}

if(btnStartCreate) btnStartCreate.addEventListener('click', startWalletCreation);
const customModal = document.getElementById('customQRModal');
const btnClose1 = document.getElementById('btn-close-custom-qr');
const btnClose2 = document.getElementById('btn-close-custom-qr-2');

function openCustomModal() {
    customModal.classList.remove('hidden');
}
function closeCustomModal() {
    customModal.classList.add('hidden');
}

if(btnClose1) btnClose1.addEventListener('click', closeCustomModal);
if(btnClose2) btnClose2.addEventListener('click', closeCustomModal);
if(customModal) {
    customModal.addEventListener('click', (e) => {
        if (e.target === customModal) closeCustomModal();
    });
}

// Helper to render QR
function renderQrInModal(payloadJson, title="Wallet QR", desc="Scan with your mobile app") {
    openCustomModal();
    const titleEl = document.getElementById('qr-modal-title');
    const descEl = document.getElementById('qr-modal-desc');
    if(titleEl) titleEl.textContent = title;
    if(descEl) descEl.textContent = desc;

    const canvas = document.getElementById('custom-qr-canvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    new QRious({
        element: canvas,
        value: typeof payloadJson === 'string' ? payloadJson : JSON.stringify(payloadJson), 
        size: 250,
        level: 'H',
        backgroundAlpha: 1,
        foreground: '#000'
    });
}

if(btnShowQr) {
    btnShowQr.addEventListener('click', () => {
        if (!wallet.address) { alert("No address generated."); return; }
        const currentAsset = document.getElementById('asset-select')?.value || 'ETH';
        console.log(currentAsset);
        renderQrInModal({
            address: wallet.address,
            crypto: currentAsset,
            action: "balance"
        }, 
        "Wallet Address QR");
    });
}

if(btnShowTxQr) {
    btnShowTxQr.addEventListener('click', () => {
        const currentAddress = wallet.address;
        const recipient = document.getElementById('recipient-address')?.value.trim();
        const amount = document.getElementById('transaction-amount')?.value.trim();
        const currentAsset = document.getElementById('asset-select')?.value || 'ETH';

        if (!currentAddress || !recipient || !amount) {
            alert("Please fill all fields (Address, Recipient, Amount).");
            return;
        }

        renderQrInModal({
            address: currentAddress,
            to: recipient,
            amount: amount,
            crypto: currentAsset,
            action: "transaction"
         }, "Transaction Request QR", "Scan this with the online app to prepare the transaction");
    });
}

// Helper to populate Signer select with Members loaded from cache
// MODIFIED: Uses "Toughkey 1/2/3" based on index
function updateSignerDropdown() {
    const signerSelect = document.getElementById('signer-select');
    if(!signerSelect) return;
    
    signerSelect.innerHTML = '<option value="" selected disabled>Select TK</option>';
    
    // Participants are populated when selecting the wallet (from API 'members' field)
    if (wallet.participants && wallet.participants.length > 0) {
        wallet.participants.forEach((p, index) => {
            const opt = document.createElement('option');
            // p.id corresponds to real partyMemberID (GUID)
            opt.value = p.id; 
           
             // FORCED LABEL: Toughkey 1, Toughkey 2, etc.
            opt.textContent = `Toughkey ${index + 1}`;
            signerSelect.appendChild(opt);
        });
    }
}

// ============================================
// SIGNATURE AND QR GENERATION LOGIC (MULTI-PARTY)
// ============================================
if(btnSignTx) {
    btnSignTx.addEventListener('click', async () => {
        if (!messageToSign) {
            setPrompt("‚ö†Ô∏è Error: No message to sign. Please Scan QR first.", { force: true });
            return;
        }
        
        if (!currentSessionId) {
             setPrompt("‚ö†Ô∏è Error: Session ID missing. Please rescan QR.", { force: true });
             return;
        }

        // If quorum already reached
        if (currentSignatures.size >= 2) {
             setPrompt("‚úÖ Transaction already fully signed!", { force: true });
             return;
       
         }

        // 1. Get ID from dropdown instead of prompt
        const signerSelect = document.getElementById('signer-select');
        const keyId = signerSelect.value; // This is now the member GUID
        const signerText = signerSelect.options[signerSelect.selectedIndex].text;
        // 2. Validate Dropdown Input
        if (!keyId || keyId === "") {
            setPrompt("‚ö†Ô∏è Please select a Signer from the dropdown list.", { force: true });
            return;
        }

        // 3. Duplicate check
        if (currentSignatures.has(keyId)) {
            setPrompt(`‚ö†Ô∏è ${signerText} has already signed! Please select a different device.`, { force: true });
            return;
        }

        // 4. PIN REQUEST
        setPrompt(`Please insert the PIN for ${signerText}`);
        const pin = await askPin(signerText); // Await user input
        
        if (!pin) {
            setPrompt("Operation cancelled (No PIN entered).", { force: true });
            return;
        }
        
        // 5. Encrypt PIN
        const encryptedPin = encryptUsingAES(pin);
        // 6. UI Loading state
        const originalText = btnSignTx.innerHTML;
        btnSignTx.disabled = true;
        btnSignTx.innerHTML = `<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Signing...`;
        
        setPrompt(`‚è≥ Tap your ${signerText} to sign...`, { force: true });
        try {
            // ---------------------------------------------------------
            // SIGNATURE API CALL (Signature/sign)
            // ---------------------------------------------------------
            // Here we pass the real partyMemberID (GUID)
            const signSessionPayload = {
                sessionID: currentSessionId,
                partyMemberID: keyId, 
                pin: encryptedPin
            };
            console.log("Sending SignSession Request:", signSessionPayload);

            const signRes = await fetch('https://localhost:44379/api/Signature/sign', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(signSessionPayload)
            });
            if (!signRes.ok) {
                 const errData = await signRes.json().catch(()=>({}));
                 throw new Error(errData.message || `API Error ${signRes.status}`);
            }
            const signData = await signRes.json();
            console.log("Sign API Success:", signData);

            // Add to signers
            currentSignatures.add(keyId);
            const count = currentSignatures.size;

            if (count < 2) {
                // PARTIAL
                setPrompt(`‚úÖ Signed with ${signerText}. One more signature needed.`, { force: true });
                btnSignTx.innerHTML = `‚úçÔ∏è Sign (${count}/2)`;
            } else {
                // COMPLETED (2 of 3)
                const signature = signData.resultObject;
                console.log("Threshold reached. TSS Signing Completed.");
                
                const currentAsset = document.getElementById('asset-select').value;

                // Final payload to show in QR
                const signedPayload = {
                    action: "sign",
                    rawTransaction: rawTransaction,
                    signedInput: signature,
                    crypto: currentAsset
                };
                renderQrInModal(
                    signedPayload, 
                    "Signature Generated", 
                    "Threshold met (2/3). Scan this QR to broadcast."
                );
                // Update button to final state
                btnSignTx.innerHTML = `‚úÖ Show Result QR`;
                btnSignTx.classList.remove('btn-success');
                btnSignTx.classList.add('btn-primary');
                
                setPrompt("üéâ Threshold reached! Transaction fully signed.", { force: true });
                btnSignTx.onclick = () => {
                     renderQrInModal(signedPayload, "Signature Generated", "Scan this QR to broadcast.");
                };
            }

        } catch (e) {
            console.error("Signing error:", e);
            setPrompt(`‚ùå Error during signing: ${e.message}`, { force: true });
            btnSignTx.innerHTML = originalText;
        } finally {
            btnSignTx.disabled = false;
            // If not finished, restore text with correct count
            if (currentSignatures.size < 2) {
                 btnSignTx.innerHTML = `‚úçÔ∏è Sign (${currentSignatures.size}/2)`;
            }
        }
    });
}

// ============================================
// QR SCANNER LOGIC (WEBCAM)
// ============================================
const btnScanQr = document.getElementById('btn-scan-qr');
const btnScanRecipient = document.getElementById('btn-scan-recipient'); // NEW
const scanModal = document.getElementById('scanQRModal');
const btnCloseScan = document.getElementById('btn-close-scan');
let html5QrCode = null;

// NEW: Scanning State
// 'TX' = Scanning a transaction to sign (JSON)
// 'ADDR' = Scanning a recipient address (String)
let activeScanMode = 'TX'; 

async function startQrScanner() {
    if (!scanModal) return;
    scanModal.classList.remove('hidden');
    if (!html5QrCode) html5QrCode = new Html5Qrcode("qr-reader");
    const config = { fps: 10 };
    console.log("Avvio scanner mode:", activeScanMode);
    try {
        await html5QrCode.start({ facingMode: "environment" }, config, onScanSuccess, onScanFailure);
        console.log("Camera avviata (environment)");
    } catch (err) {
        console.warn("Environment camera fallita, provo user...", err);
        try {
             await html5QrCode.start({ facingMode: "user" }, config, onScanSuccess, onScanFailure);
             console.log("Camera avviata (user)");
        } catch(e2) {
             console.error("Errore fatale camera:", e2);
             alert("Impossibile avviare la fotocamera. Verifica di essere in HTTPS o su localhost.");
             closeScanModal();
        }
    }
}

async function closeScanModal() {
    if (html5QrCode && html5QrCode.isScanning) {
        try { await html5QrCode.stop();
        } catch (e) { console.error(e); }
    }
    scanModal.classList.add('hidden');
}

async function onScanSuccess(decodedText, decodedResult) {
    console.log("--- QR LETTO ---");
    console.log(decodedText);

    // üîπ Caso 1: stai scansionando un ADDRESS
    if (activeScanMode === 'ADDR') {
        let cleanAddr = decodedText.trim();

        // supporto per formati tipo "ethereum:0x123..." o "bitcoin:1ABC..."
        const lower = cleanAddr.toLowerCase();
        if (lower.startsWith('ethereum:') || lower.startsWith('bitcoin:')) {
            cleanAddr = cleanAddr.split(':')[1];
        }
        // rimuove eventuali query tipo "?amount=..."
        if (cleanAddr.includes('?')) {
            cleanAddr = cleanAddr.split('?')[0];
        }

        const recipientInput = document.getElementById('recipient-address');
        if (recipientInput) {
            recipientInput.value = cleanAddr;
            // piccolo feedback visivo
            recipientInput.style.backgroundColor = "#d4edda";
            setTimeout(() => {
                recipientInput.style.backgroundColor = "";
            }, 1000);
        }

        await closeScanModal();
        setPrompt("Address loaded from QR.", { force: true });
        return;
    }

    // üîπ Caso 2: modalit√† standard (TX da firmare)
    try {
        const data = JSON.parse(decodedText);
        console.log("JSON parsato:", data);

        // CASE A: Transaction Data (RawTx + Hash)
        if (data.rawTxBytes && data.messagesToSign) {
            console.log("Riconosciuto come Transazione TSS");
            if(!partyId) {
                setPrompt("‚ö†Ô∏è Error: No Wallet selected. Please select a wallet.", { force: true });
                await closeScanModal();
                return;
            }

            // RESET SIGNATURE STATE
            currentSignatures.clear();
            currentSessionId = null; // Reset session

            if(btnSignTx) {
                btnSignTx.disabled = false;
                btnSignTx.innerHTML = `‚úçÔ∏è Sign (0/2)`;
                btnSignTx.classList.remove('btn-primary', 'animate__pulse');
                btnSignTx.classList.add('btn-success');
                btnSignTx.onclick = null;
            }

            rawTransaction = data.rawTxBytes;
            if (Array.isArray(data.messagesToSign) && data.messagesToSign.length > 0) {
                const msgItem = data.messagesToSign[0];
                if (typeof innerData === 'string') {
                    try { innerData = JSON.parse(innerData); } catch (e) {}
                }
                console.log(msgItem);
                messageToSign = msgItem?.Data ||
                                msgItem?.data;
                console.log("Hash estratto:", messageToSign);
            } else {
                console.warn("Invalid messagesToSign");
            }
            
            const hashDisplay = document.getElementById('tx-hash-display');
            if(hashDisplay) {
                hashDisplay.value = messageToSign;
                hashDisplay.style.backgroundColor = "#d4edda";
                hashDisplay.style.color = "#155724";
                setTimeout(()=>{
                    hashDisplay.style.backgroundColor = "#f8f9fa";
                    hashDisplay.style.color = "#666";
                }, 1500);
            }

            setPrompt("‚è≥ Initializing Signing Session...", { force: true });

            try {
                const createPayload = { partyGUID: partyId, messageToSign: messageToSign };
                console.log("Calling Signature/create:", createPayload);
                
                const createRes = await fetch('https://localhost:44379/api/Signature/create', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(createPayload)
                });
                if(!createRes.ok) throw new Error("Failed to init session");
                const createData = await createRes.json();
                currentSessionId = createData.resultObject;
                console.log("Session ID obtained:", currentSessionId);
                
                setPrompt("Session Ready. Select a device and click 'Sign' (2 required).", { force: true });
                if(btnSignTx) {
                    btnSignTx.disabled = false;
                    btnSignTx.classList.add('animate__animated', 'animate__pulse');
                }

            } catch(apiErr) {
                console.error(apiErr);
                setPrompt("‚ùå Error initializing signing session.", { force: true });
            }

            await closeScanModal();
            return;
        }

        // CASE B: Recipient Address JSON { "address": "..." } (legacy)
        const recipientInput = document.getElementById('recipient-address');
        if (recipientInput && data.address) {
            recipientInput.value = data.address;
            setPrompt("Address loaded: " + data.address, { force: true });
            await closeScanModal();
            return;
        }
        
        // CASE C: JSON ma non riconosciuto
        setPrompt("Unrecognized QR Format (JSON).", { force: true });
        await closeScanModal();
    } catch (e) {
        console.warn("Errore parsing JSON o testo semplice:", e);
        setPrompt("Unrecognized QR (Text).", { force: true });
        await closeScanModal();
    }
}


function onScanFailure(error) { 
    // console.warn(error);
}

// Main Scan Button (Transaction Hash)
if (btnScanQr) {
    btnScanQr.addEventListener('click', () => {
        activeScanMode = 'TX';
        startQrScanner();
    });
}

// New Scan Button (Recipient Address)
if (btnScanRecipient) {
  btnScanRecipient.addEventListener('click', () => {
    activeScanMode = 'ADDR';
    startQrScanner();
  });
}

if (btnCloseScan) btnCloseScan.addEventListener('click', closeScanModal);
if (scanModal) {
    scanModal.addEventListener('click', (e) => {
        if (e.target === scanModal) closeScanModal();
    });
}

// ============================================
// COPY TO CLIPBOARD LOGIC
// ============================================
const btnCopyAddr = document.getElementById('btn-copy-addr');
if (btnCopyAddr) {
    btnCopyAddr.addEventListener('click', () => {
        const addrText = document.getElementById('created-address').textContent;
        if (!addrText) return;

        navigator.clipboard.writeText(addrText).then(() => {
            // Visual Feedback
            const originalHTML = btnCopyAddr.innerHTML;
            btnCopyAddr.innerHTML = '‚úÖ';
            setTimeout(() => {
                btnCopyAddr.innerHTML = originalHTML;
            }, 2000);
        }).catch(err => {
            console.error('Failed to copy: ', err);
            setPrompt('‚ùå Failed to copy to clipboard.');
        });
    });
}


// ============================================
// PIN LOGIC 
// ============================================
const pinBlock = document.getElementById('pin-block');
const pinLabel = document.getElementById('pin-card-label');
const pinInput = document.getElementById('pin-input');
if(document.getElementById('btn-submit-pin'))
    document.getElementById('btn-submit-pin').addEventListener('click', submitPin);
if(pinInput)
    pinInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') submitPin(); });
function showPin(show, cardLabel='') {
  if(pinBlock) pinBlock.classList.toggle('d-none', !show);
  if(pinLabel) pinLabel.textContent = cardLabel || '';
  if (show && pinInput) setTimeout(() => pinInput.focus(), 0);
}

// Function to ask for PIN returning a Promise
function askPin(cardLabel) {
  showPin(true, cardLabel);
  return new Promise((resolve) => { 
      pendingPinResolve = (val) => { 
          resolve(val); 
          pendingPinResolve = null; 
      }; 
  });
}

function submitPin() {
  const val = pinInput.value.trim();
  if (!val) return;
  pinInput.value = '';
  showPin(false);
  if (pendingPinResolve) pendingPinResolve(val);
}


let maxPE = 0;
let maxPKR = 0;
let reachedGroupReady = false;
// ============================================
// MODIFIED CORE CREATION FLOW
// ============================================
async function startWalletCreation() {
  try {
    promptLocked = false;
    btnStartCreate.disabled = true;
    btnStartCreate.textContent = BTN_TEXT_INPROGRESS;
    btnShowQr.disabled = true;
    if(btnShowTxQr) btnShowTxQr.disabled = true;
    
    successHandled = false;
    holds.clear();
    updateCreateButton();
    successReceived = false;
    countersLocked = false;
    reachedGroupReady = false;
    
    maxPE = 0; maxPKR = 0; updatePE(0); updatePKR(0);
    setPrompt('');
    const selectedAsset = (document.getElementById('asset-select')?.value || 'BTC').toUpperCase();
    
    // 1. CREATE PARTY
    const createPartyData = {
      assets: [selectedAsset],
      size: 3,
      threshold: 2,
      thresholdConfig: []
    };
    const createPartyJson = JSON.stringify(createPartyData);
    console.log(createPartyJson);
    const createPartyres = await fetch( 'https://localhost:44379/api/Party/create', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: createPartyJson
      });
    const partyData = await createPartyres.json();
    partyId = partyData.resultObject[0];
    console.log("Party ID:", partyId);
    // 2. ADD MEMBERS
    const AddMembersToPartyData = {
      partyID: partyId,
      members: [
        { externalPartyMemberID: "toughkey1-member", level: 0, name: "Toughkey 1", label: "Toughkey 1" },
        { externalPartyMemberID: "toughkey2-member", level: 0, name: "Toughkey 2", label: "Toughkey 2" },
        { externalPartyMemberID: "toughkey3-member", level: 0, name: "Toughkey 3", label: "Toughkey 3" }
      ]
    };
    const AddMembersJson = JSON.stringify(AddMembersToPartyData);
    const AddMembersRes = await fetch( "https://localhost:44379" + '/api/Party/addMembers', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: AddMembersJson
    });
    const AddMembersData = await AddMembersRes.json();
    console.log("Members Added:", AddMembersData);

    const members = AddMembersData.resultObject;
    // *** FIX: SAVE MEMBERS IN GLOBAL STATE ***
    wallet.participants = members;
    updateSignerDropdown();
    // Update UI

    // Object to store encrypted PINs and reuse them in Save loop
    let memberCredentials = {};
    // =====================================================
    // 3. AUTHORIZATION LOOP (Authorize)
    // =====================================================
    let enrolledCount = 0;
    // LOCAL ENROLLMENT COUNTER
    for (const member of members) {
        const memberId = member.id;
        const memberName = member.name || "Unknown Device";
        console.log(`Starting authorization for member ${memberId} (${memberName})`);
        // A. Ask for PIN
        setPrompt(`Please insert the PIN for your ${memberName}`);
        const pin = await askPin(memberName);
        
        // B. Encrypt PIN
        const encryptedPin = encryptUsingAES(pin);
        // Save encrypted PIN for next loop (Save)
        memberCredentials[memberId] = encryptedPin;
        // C. Prompt TAP
        setPrompt(`Tap your ${memberName} to authorize creation`);
        // D. Authorize API call
        const authBody = JSON.stringify({ participantId: memberId, pin: encryptedPin, SerialNumbersToExclude: [] });
        const authRes = await fetch(`https://localhost:44379/api/Party/authorize`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: authBody
        });
        if (!authRes.ok) throw new Error(`Authorization failed for ${memberName}: ${authRes.status}`);
        
        console.log(`Authorization successful for ${memberName}`);
        // *** UPDATE ENROLLED COUNTER ***
        enrolledCount++;
        updatePE(enrolledCount);
        // E. Remove and Wait
        setPrompt(`Remove your ${memberName} and wait`);
        await sleep(4000);
    }

    // =====================================================
    // *** REQUESTED MOCK INTERLUDE ***
    // =====================================================
    setPrompt("We are starting the wallet creation... Please wait.");
    await sleep(3500); // Wait 3.5 seconds
    // =====================================================


    // =====================================================
    // 4. START ACTIVATION (Intermediate)
    // =====================================================
    console.log("Calling Start Activation...");
    const startActivationData = { partyID: partyId };
    const StartActivationJson = JSON.stringify(startActivationData);
    const StartActivationRes = await fetch( "https://localhost:44379" + '/api/Activation/start', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: StartActivationJson
    });
    // We don't fetch the address yet, as requested
    const StartActivationResData = await StartActivationRes.json();
    console.log("Start Activation Result (Intermediate):", StartActivationResData);

    // =====================================================
    // 5. SHARE SAVE LOOP (Save)
    // =====================================================
    let sharesCount = 0;
    // LOCAL SHARES COUNTER
    for (const member of members) {
        const memberId = member.id;
        const memberName = member.name || "Unknown Device";
        
        // Retrieve previously saved encrypted PIN
        const reusedEncryptedPin = memberCredentials[memberId];
        console.log(`Starting Save Share for member ${memberId}`);

        // A. Prompt TAP for saving
        setPrompt(`Tap your ${memberName} to save the private share`);
        // B. Save API call (using same input as authorize)
        const saveBody = JSON.stringify({ 
            partyId: partyId,
            participantId: memberId, 
            pin: reusedEncryptedPin, 
            SerialNumbersToExclude: [] 
        });
        // Fetch simulates waiting for card tap
        const saveRes = await fetch(`https://localhost:44379/api/Party/save`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: saveBody
        });
        if (!saveRes.ok) throw new Error(`Save Share failed for ${memberName}: ${saveRes.status}`);
        console.log(`Save Share successful for ${memberName}`);
        // *** UPDATE SHARES COUNTER ***
        sharesCount++;
        updatePKR(sharesCount);
        // C. Remove and Wait
        setPrompt(`Remove your ${memberName} and wait`);
        await sleep(4000);
    }

    // =====================================================
    // 6. END ACTIVATION (Final)
    // =====================================================
    console.log("Calling End Activation...");
    const EndActivationRes = await fetch( "https://localhost:44379" + '/api/Activation/end', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ partyID: partyId }) 
    });
    const EndActivationResData = await EndActivationRes.json();
    console.log("End Activation Result (Final):", EndActivationResData);
    // SUCCESS - Retrieve final address
    const finalAddr = EndActivationResData.resultObject.address;
    wallet.address = finalAddr;
    // --- UI UPDATE ---
    const walletSelect = document.getElementById('existing-wallets');
    if(walletSelect) {
        const newOpt = document.createElement('option');
        newOpt.value = finalAddr;
        newOpt.textContent = `${finalAddr} (${selectedAsset})`;
        newOpt.dataset.asset = selectedAsset;
        newOpt.dataset.partyId = partyId;
        newOpt.dataset.fullAddress = finalAddr;
        newOpt.selected = true;
        walletSelect.appendChild(newOpt);
    }
    
    setPrompt('The address of the wallet is ' + finalAddr);
    showCreatedAddress(finalAddr);
    successReceived = true; 
    updateCreateButton();

  } catch (e) {
    console.error('[Create] Error:', e);
    setPrompt("Error: " + e.message);
    successReceived = false;
    btnStartCreate.disabled = false;
    btnStartCreate.textContent = BTN_TEXT_IDLE;
    btnShowQr.disabled = true;
    if(btnShowTxQr) btnShowTxQr.disabled = true;
  }
}

// ============================================================
// EXISTING WALLET LIST LOGIC (CACHE + SELECT FIX)
// ============================================================

const walletSelect = document.getElementById('existing-wallets');
// 1. Function to load wallets on startup
async function loadExistingWallets() {
    try {
        console.log("[Init] Fetching existing wallets...");
        // API call for wallet list
        const res = await fetch('https://localhost:44379/api/Party');
        if (!res.ok) throw new Error(`API Error: ${res.status}`);
        
        const data = await res.json();
        // *** FIX: SAVE DATA IN CACHE ***
        cachedParties = data.resultObject || [];
        console.log("Parties loaded:", cachedParties);

        if(walletSelect) {
            walletSelect.innerHTML = '<option value="">-- Create New --</option>';
            cachedParties.forEach(p => {
                const addr = p.partyAddress; 
                const partyIdVal = p.id || p.partyGUID;
                const asset = p.assetCode;

                if (addr) {
                    
                    const opt = document.createElement('option');
                    opt.value = addr;
                    opt.textContent = `${addr} (${asset})`; 
                    // Save ID in dataset, retrieve the rest from cache
  
                    opt.dataset.partyId = partyIdVal;
                    walletSelect.appendChild(opt);
                }
            });
            walletSelect.value = "";
            if (btnStartCreate) {
                btnStartCreate.textContent = "Create new wallet";
                btnStartCreate.disabled = false;
            }
            
            if (createdAddressWrap) createdAddressWrap.classList.add('d-none');
            setPrompt("Ready to create a new wallet.");
        }

    } catch (e) {
        console.error("[Init] Error loading wallets:", e);
    }
}

// 2. Event Listener for selection change
if (walletSelect) {
    walletSelect.addEventListener('change', (e) => {
        const selectedOption = walletSelect.selectedOptions[0];
        const val = selectedOption.value;
        const infoText = document.getElementById('pin-instruction-text'); // Reference to text

        if (val) {
            // EXISTING WALLET SELECTED
            // HIDE INFO TEXT
        
             if(infoText) infoText.classList.add('d-none'); 

            const pid = selectedOption.dataset.partyId;
            
          
            // *** FIX: SEARCH CACHE TO GET ALL DATA (MEMBERS INCLUDED) ***
            const partyData = cachedParties.find(p => (p.id == pid || p.partyGUID == pid));

          
            if (partyData) {
                wallet.address = partyData.partyAddress;
                partyId = partyData.id || partyData.partyGUID;
          
                
                // *** CRITICAL FIX: POPULATE WALLET PARTICIPANTS USING REAL RESPONSE DATA ***
    
                wallet.participants = partyData.members || partyData.partyMembers || [];
                const asset = partyData.assetCode || 'ETH';
          
                 updateSignerDropdown(); // Update signer select with new members

                 // *** UPDATE: SET COUNTERS TO MAX (Existing Wallet) ***
                 updatePE(3);
                 updatePKR(3);

                showCreatedAddress(wallet.address);
                // UI Updates
                const assetDropdown = document.getElementById('asset-select');
                if (assetDropdown && asset && asset !== 'UNKNOWN') {
                    assetDropdown.value = asset;
                }

                if (btnShowQr) btnShowQr.disabled = false;
                if (btnShowTxQr) btnShowTxQr.disabled = false;
                if (btnStartCreate) {
                    btnStartCreate.textContent = "Wallet Selected";
                    btnStartCreate.disabled = true;
                }

                console.log("Wallet Loaded via Cache:", wallet);
                setPrompt(`Wallet loaded: ${asset} - Members loaded: ${wallet.participants.length}`);
            }

        } else {
            // "-- Create New --" OPTION SELECTED
            // SHOW INFO TEXT
            if(infoText) infoText.classList.remove('d-none');
            if (btnStartCreate) {
                btnStartCreate.textContent = "Create new wallet";
                btnStartCreate.disabled = false;
            }
            createdAddressWrap.classList.add('d-none');
            wallet.address = null;
            wallet.participants = []; // Reset
            updateSignerDropdown();
            // Reset dropdown
            
            // *** RESET COUNTERS ***
            updatePE(0);
            updatePKR(0);

            partyId = null;
            if (btnShowQr) btnShowQr.disabled = true;
            if (btnShowTxQr) btnShowTxQr.disabled = true;
            
            setPrompt("Ready to create a new wallet.");
        }
    });
}

// Load list on page startup
loadExistingWallets();
</script>